#! /usr/bin/perl

# Copyright (c) 2020 Marc Espie <espie@openbsd.org>
# 
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


use strict;
use warnings;

use WWW::Mechanize;
use HTML::TreeBuilder;

sub get_tree
{
	my $url = shift;
	my $mech = WWW::Mechanize->new;
	$mech->get($url);
	my $tree = HTML::TreeBuilder->new;
	$tree->parse($mech->content);
	$tree->eof;
	$tree->elementify;
	return $tree;
}

my $badges = {
	'dwarven brewery' => 0,
	'treant guild' => 1,
	'bakers guild' => 2,
	'carpenters guild' => 3,
	'farmers delight' => 4,
	'blacksmith guild' => 5,
	'luxurious flacon' => 6,
	'golden bracelet' => 7,
	'diamond necklace' => 8,
	'elegant statue' => 9,
	'wand' => 10,
	'magic potion' => 11,
	'witch hat' => 12,
	'wonder society' => 13,
	'elvarian guard' => 14,
	'sack of coins' => 15,
};

sub print_csv_line
{
	my ($bools, $points) = @_;
	my @line;
	for my $i (0..8) {
		push(@line, $bools->[$i] // 0);
	}
	for my $j (0..15) {
		push(@line, $points->{$j} // 0);
	}
	print join(', ', @line), "\n";
}

sub parse_map_row
{
	my $map = pop;
	my @td = @_;
	my $header = shift @td;
	my $t = $header->as_text;
	if ($t eq 'Waypoint' or $t eq 'TOTAL') {
		return;
	} 

	# weed out score total and create text array
	my @parsed;

	for my $p (@td) {
		my $t = $p->as_text;
		if ($t =~ m/.*00$/) {
			next;
		}
		push(@parsed, $t);
	}

	my $points = [];
	# lines are alternating: orange/blue/green, with Qty/Type
	my $color = 0;
	while (@parsed >= 2) {
		my ($qty, $type) = (shift @parsed, shift @parsed);
		$type =~ tr/A-Z/a-z/;
		# some points DON'T have the same number of badges,
		# that results in blank lines
		if (defined $badges->{$type}) {
			$points->[$color]{$badges->{$type}} = $qty;
		}
		$color++;
		if ($color == 3) {
			$color = 0;
		}
	}
	# so we want an array with each path tagged with a bool
	my $idx = $map * 3;
	if ($t eq 'Start') {
		# start points have 3* the same color, BUT it's the same point
		my $bools = [];
		$bools->[$idx] = $bools->[$idx+1] = $bools->[$idx+2] = 1;
		print_csv_line($bools, $points->[0]);
	} else {
		for (my $i = 0; $i != 3; $i++) {
			my $bools = [];
			$bools->[$idx+$i] = 1;
			print_csv_line($bools, $points->[$i]);
		}
	}
}

sub parse_tree
{
	my $tree = shift;

	# extract the 3 maps, numbered
	my $map = 0;
	for my $l ($tree->look_down('_tag', 'table', 
	    'class', qr{fa-stage-chart.*})) {
		my @tr = $l->look_down('_tag', 'tr');
		my @td = ();
		while (@tr != 0) {
			my $tr = shift @tr;
			my @new = $tr->look_down('_tag', 'td');
			if (@new == 0) {
				if (@td == 0) {
					next;
				}
				parse_map_row(@td, $map);
				@td = ();
			} else {
				push(@td, @new);
			}
		}
		$map++;
	}
}


my $url = shift // "https://elvengems.com/fellowship-adventures/march-2020-adventure/";


my $tree = get_tree($url);
parse_tree($tree);

